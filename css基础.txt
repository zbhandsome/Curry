一、
01通过标签来修改样式的缺点：
1、需要记忆哪些标签有哪些属性，如果该标签没有这个属性，那么设置了也没有效果
2、当需求变更时我们需要修改大量的代码才能满足现有的需求
3、HTML只有一个作用就是来添加语义
所以在企业开发中修改样式都是交给CSS来做
02通过CSS来修改样式有什么好处？
1、不用记忆哪些属性属于哪个标签
2、当需求变更时我们不需要修改大量的代码就可以满足需求
3、在前端开发中CSS只有一个作用就是用来修改样式
格式：写在head标签里，title标签下面
<style type="text/css">
       h1{
             text-align:center;
             color:red;
             font-family:'微软雅黑';
       }
</style>

注意点：style标签必须写在head标签的开始和结束标签之间
所有的CSS代码全部写在style开始标签和结束标签中间
style标签中的type其实可以不用写，默认就是type=“text/css”
设置样式时必须按照固定的格式来设置.key:value;(其中：和；一定不能省略)
二、
1、规定文字样式的属性
格式：font-style:italic;
取值：normal：正常的，默认就是正常的      italic：倾斜的
快捷键：f+s/ f+s+n + Tab
2、规定文字粗细的属性
格式：font-weight：bold;
取值：单词取值bold 加粗  bolder  更粗  lighter  细线
快捷键：f+w+b+Tab
数字取值：100-900之间整百取值
3、规定文字的大小属性
格式：font-size：30px;
单位：px：（像素 pixel）
注意点：通过font-size设置大小一定要带单位
快捷键：f+z+30+Tab
4、规定文字字体的样式
格式：font-family:"楷体"；
注意点：如果取值是中文需要用双引号或者单引号括起来
设置的字体必须是用户电脑已经安装的字体
快捷键;f+f+Tab
补充：1、如果设置的字体不存在，那么系统会使用默认字体来显示宋体
          2、如果设置的字体不存在，而我们又不想用默认的字体来显示怎么办？
               可以给字体设置备选方案
               格式：font-family："字体一"，"备选方案一"，...;
          3、如果想给中文和英文分别单独设置字体，怎么办？
               但凡是中文字体里面都包含了英文字体
               但凡是英文字体里面都没有包含中文
               也就是说中文字体可以处理英文，而英文字体不能处理中文
               注意点：如果想给界面中的英文单独设置字体那么英文字体必须写在中文前面
补充：在企业开发中最常见的字体有以下几个	
中文：宋体/黑体/微软雅黑
英文：“Time New Roman”/Arial
并不是英文名称就是英文字体，因为中文字体其实都有自己的英文名称，所以是不是中文字体主要看能不能处理中文
宋体：SimSun/黑体：SimHei/微软雅黑：Microsoft Yahei
文字属性的简写：
缩写格式：font:style  weight  size  family;
例如：font:italic bold  10px "楷体"；
注意点:1、在这种缩写格式中有的属性值可以省略
style/weight  不仅可以省略，还可以交换位置
2、在这种缩写格式中有的属性不可以省略
size/family 并且位置固定化，不可移动，size一定要写在famil的前面，而且size和family必须写在所有属性的最后
5、文本属性：
01、文本装饰的属性：
格式：text-decoration：underline；
取值;underline   下划线/line-through  删除线/overline  上划线/none  什么都没有，最常见的用途就是用于去掉超链接的下划线
02、文本对齐的属性：
格式：text-align：center；
取值：left/center/right
03、文本缩进的属性：
格式:text-indent:2em;
取值：em是单位，一个em就是一个文字的宽度
6、颜色控制属性
在CSS中如何通过color属性来修改文字颜色
格式：color：值
取值：
01、英文单词
一般情况下常见的颜色都有对应的英文单词，但是英文单词能够表达的颜色是有限制的，也就是说不是所有的颜色都能够通过英文单词来表达
02、rgb
rgb就是三原色，R(red),G(green),B(blue)
格式：rgb（0，0，0）数字代表颜色的光源原件显示的亮度，取值是0-255之间 0是不发光
在前端开发中其实并不常用黑色
只要让红绿蓝的值都一样就是灰色，而且如果这三个值越小那么就越偏黑色，越大就越偏白色
03、rgba
a是透明度的意思，取值是0-1取值越小就越透明
04、十六进制
在前端开发中通过十六进制来表示颜色，其实本质就是RGB十六进制中是通过每两位表示一个颜色
例如：#FFEE00      FF表示R    EE表示G    00表示B
什么是十六进制？
十六进制和十进制都是一种计数方法
在十进制中取值范围0-9，每逢十进一（0，1，2，3，4，5，6，7，8，9，10）
在十六进制中取值范围0-F，逢16进一（0，1，2，3，4，5，6，7，8，9，a,b,c,d,e,f,10）
十六进制和十进制的转换公式：用十六进制的第一位*16+十六进制的第二位=十进制
十六进制的12==1*16+2=十进制的18
FF==F*16+F==15*16+15=240+15=255
00==0*16+0=0
05、十六进制的缩写
在CSS中只要十六进制的颜色每两位的值都是一样的就可以简写为一位
例如：#ffee00==#fe0
如果当前颜色对应的两位数字不一样，那么就不能简写
如果两位数字相同不是属于同一个颜色，也不能简写的
三、选择器
1、标签选择器
作用：根据指定的标签名称，在当前的界面中找到所有该名称的标签，然后设置属性
格式：
标签名称{
                属性：值；
                }
注意点：标签选择器选择的是当前界面中所有的标签；不管藏得多深都可以找到；只要是HTML中的标签就可以作为标签选择器
2、id选择器
作用：就是根据指定的id名称找到对应的标签，然后设置属性
格式：#id名称{
                        属性：值；
		}
注意点：1、每个HTML标签都有一个属性叫做id，也就是说每个标签都可以设置id
2、在同一个界面中的名称是不可以重复的
3、在编写id选择器时一定要在id名称前面加上#
4、id的名称是有一定的规范的
4.1、id的名称只能由数字/字母.下划线组成
a-z  0-9  _
4.2、id名称不能以数字开头，一般都是以字母开头
4.3、id名称不能是HTML的标签名称
4.3、在企业开发中一般情况下如果仅仅是为了设置样式，我们不会使用id，因为在前端开发中id是留给js使用的


3、类选择器（class）
作用：根据指定的类标签找到对应的标签，然后设置属性
格式：.类名{
            属性：值；
               }
注意点：
1、每个标签都有一个属性叫做class也就是说每个标签都可以设置类名
2、在同一界面中class的名称是可以重复的
3、在编写class选择器时一定要在名称前面加上英文的句号.
4、类名的命名规范和id名称的命名规范一样
5、类名就是给某个特定的标签设置样式的
6、在HTML中每个标签可以绑定多个标签
格式：
<标签名称 class  “类名1  类名2”>


id选择器和类选择器的区别
id相当于人的身份证不可以重复
class相当于人的名称可以重复

一个HTML标签只能绑定一个id名称
一个HTML可以绑定多个class名称

id选择器和class选择器的区别？
id选择器是以#开头
class选择器是以.开头

在企业开发中到底是用id选择器还是用class选择器?
id一般情况下是给js使用的，除非特殊情况，否则不要使用id去设置

在企业开发中一个开发人员对类的使用可以看出这个开发人员的技术水平
一般情况下，在企业开发中要注重冗余代码的抽取，可以将一些公共代码抽取到一个类选择器中，然后让标签和这个类选择器绑定即可

后代选择器
作用：找到指定的标签的所有特定的后代标签，设置属性
格式：标签名称1 标签名称2{
          属性：值；
          }
先找到名称叫做标签名称1的标签，然后再在这个标签下面去查找所有名称叫做标签名称2的所有标签，然后再设置属性
注意点：
1后代选择器必须用空格隔开
2后代不仅仅是儿子，也包括孙子/重孙子
只要是放到指定标签中的都是后代
3后代选择不仅仅可以使用标签名称，还可以使用其他选择器
4可以无限衍生

子元素选择器
作用：找到指定标签中的所有的直接子元素，然后设置属性
格式：标签名称1>标签名称2{
属性：值；}
注意点：
1子元素只会查找儿子，不会查找其他被套嵌的标签
2子元素选择器之间要用>连接并且不能有空格
3子元素选择器不仅可以使用标签名称，还可以使用其他选择器可以混着用
4可以无限衍生

后代选择器和子元素选择器之间的区别
1后代选择器使用空格作为连接符号
  子元素使用>作为连接符号
2后代选择器会选中指定标签中所有的特定后代标签，也就是会选中儿子/孙子...只要是被放到指定标签中的特定标签都会被选中
子元素选择器只会选中特定指定标签中所有的直接标签，也就是只会选中特定的儿子标签

后代选择器和子元素之间的共同点
1都可以使用标签名称/id名称/class名称来作为选择器
2都可以通过连接符号一直延续下去

在企业开发中该如何选择
如果只想选中指定的标签中的所有特定的标签，那么就使用后代选择器如果想选中指定标签中的所有指定儿子标签，那么就使用子元素选择器

交集选择器
作用：给所有选择器选中的标签中，相交的那部分标签设置属性
格式：选择器1选择器2{
属性：值；}
注意点：
1选择器和选择器之间没有任何的连接符号
2选择器可以使用标签名称/id名称/class名称
3交集选择器仅仅作为了解

并集选择器
作用：给所有选择器选中的标签设置属性
格式：选择器1，选择器2{
                                        属性：值；}
注意点
1并集选择器必须使用逗号来连接
2选择器可以使用标签名称/id名称/class名称

兄弟选择器
作用：只能选择同级标签
1.相邻兄弟选择器
作用：给指定选择器后面紧跟的那个选择器选中的标签设置属性
格式：选择器1+选择器2{
                                      属性：值；}
注意点：
1相邻兄弟选择器必须通过+连接
2相邻兄弟选择器只能选中紧跟其后的标签，不能选中隔开的标签

2.通用兄弟选择器CSS3
作用：给指定选择器后面的所有选择器的所有标签设置属性
格式：选择器1~选择器2{
                                      属性：值；}
注意点
1通用兄弟选择器必须使用~连接
2通用兄弟选择器选中的是指定选择器后面某个选择器选中的所有标签，无论有没有被隔开都可以

序选择器
CSS3中新增的选择器最具代表性的就是序选择器
1.同级别的第几个
：first-child 选中同级别中的第一个标签
：last-child选中同级别中的最后一个标签
不区分类型
：nth-child（n）选中同级别中的第n个标签
：nth-last-child（n）选中同级别中的倒数第（n）个标签
：only-child选中父元素中的唯一元素

：nth-child（odd/even）选中同级别中的所有奇/偶数标签
2.同类型的第几个
：first-of-type选中同级别中同类型的第一个标签
：last-of-type选中同级别同类型的最后一个标签
：nth-of-type（n）选中同级别中同类型的第n个标签
：nth-last-of-type（n）选中同级别中同类型的倒数第（n）个
：only-of-type选中父元素中的唯一类型的某个标签
：nth-of-type（odd/even）选中同类型的所有奇/偶数标签

：nth-child（Xn+Y）
X和Y是用户自定义的，而n是一个计数器，从0开始递增

属性选择器
格式：[attribute]
作用：根据指定的属性名称找到对应的标签，然后设置属性
[attribute=value]
-作用: 找到有指定属性, 并且属性的取值等于value的标签, 然后设置属性
-最常见的应用场景, 就是用于区分input属性

input[type=password]{}
<input type="text" name="" id="">
<input type="password" name="" id="">

1.属性的取值是以什么开头的
[attribute|=value]css2只能找到以-符号连接的
[attribute^=value]css3 只要是value开头的都能找到
2.属性的取值是以什么结尾的
[attribute$=value]css3
3.属性的取值是否包含某个特定的值
[attribute~=value]css2
[attribute*=value]ess3
区别在与css2里只能找到空格单独隔开的单词。
css3中只要包含value的就能找到

通配符选择器
作用：给当前界面上的所有的标签设置属性
格式：*{
             属性：值；}
注意点：由于通配符选择器是设置界面上的所有的标签的属性，所以在设置之前会遍历所有的标签，如果当前的界面上是的标签比较多，那么性能就会比较差，所以在企业开发中一般不会使用通配符选择器


继承性
作用：给父元素设置一些属性，子元素也可以使用，这个我们就称之为继承性
注意点：1.并不是所有的属性都可以继承，只有以color/font-/text-/line开头的属性才可以继承
2.在CSS的继承性中不仅仅是儿子可以继承，只要是后代都可以继承
3.CSS继承性中的特殊性
3.1a标签的文字颜色和下划线是不可以继承的
3.2h标签的文字大小是不能继承的
应用场景：
一般用于设置网页上的共性信息，例如网页的文字颜色，字体，文字大小等内容

层叠性
作用：层叠性就是CSS的处理冲突的能力
注意点：
1.层叠性只有在多个选择器选中 同一个标签，然后设置了相同的属性，才会发生层叠

优先级
作用：当多个选择器选中同一个标签，并且给同一个标签设置相同的属性时，如何层叠就以优先级来确定

优先级的判断三种方式
1.是否直接选中（直接找到对应标签）
间接选中就是继承，就是谁离目标标签比较近就听谁的
2.是否是相同选择器
如果是直接选中，并且是相同的选择器，那么谁写在后面就听谁的
3.不同选择器
如果都是直接选中的，并且不是相同类型的选择器，那么就会按照选择器的优先级来层叠
id>类>标签>通配符>继承>浏览器默认

!important
作用：用于提升某个直接选中标签的选择器中的某个属性的优先级的，可以将被指定的属性的优先级提升为最高
注意点：1.important只能用于直接选中，不能用于间接选中
2.通配符选择器选中的标签也是直接选中的
3.!important只能提升被指定的属性的优先级，其他的属性的优先级不会被提升
4.!important必须写在属性值的分号的前面
5.!important前面的感叹号不能省略！

权重问题：
作用：当多个选择器混合在一起使用时，我们就可以通过计算权重来判断谁的优先级最高
权重的计算规则
1.先计算选择器中的id个数，id多的优先级最高
2.如果id的个数一样，那么再看类名的个数，类名个数多的优先级最高
3.如果类名的个数一样，那么再看标签名称个数，标签名称多的优先级最高
4.如果id个数一样，类名个数一样，标签个数也一样，那么就不会再往下继续计算了，此时谁写在后面听谁的，也就是说优先级如果一样，那么谁写在后面听谁的
注意点：只有选择器直接选中的标签才需要计算权重


什么是div
作用：一般用于配合css完成网页的基本布局
什么是span
作用：一般用于配合css修改网页中的一些局部信息
div和span有什么区别
1.div会单独占领一行，span不会占一行
2.div是容器级的标签，而span是文本级的标签
容器级别标签和文本级标签的区别
容器级的标签可以嵌套其他所有的标签
文本级的标签只能套嵌文字/图片/超链接
注意点：哪些标签是文本级的哪些是容器级的
我们可以不用去记忆，在企业开发中一般情况下要嵌套的都是嵌套在div中，或者按照组标签来嵌套

在HTML中将所有的标签分为两类，分别是容器级和文本级标签
在css中也将所有的标签分为两类，分别是块级元素和行内元素
块级元素会独占一行，行内不会
块级元素：独占一行；如果没有设置宽度，那么默认和父元素一样，如果设置了就按设置的来
行内元素：不会独占一行；如果没有设置宽度，那么和默认的内容一样宽
行内元素是不可以设置宽度和高度的

行内块级元素：
为了能够让元素既能不独占一行又能设置宽度和高度

css元素显示模式转换
标签内设置display属性进行转换
inline：行内
block：块级
inline-block：行内块级

如何设置背景颜色
通过在css中设置background-color：属性
取值：
具体的单词/rgb/rgba/十六进制

如何设置背景图片
设置css中的background-image:url（）：的属性，就是专门设置背景的图片的
注意点：
1、图片的地址必须放在url()中,图片的地址可以是本地的地址，也可以是网络的地址
2、如果图片的大小没有标签的大小，那么会自动在水平和垂直方向平铺和填充
3、如果网页上出现了图片，那么浏览器就会再次发送请求获取图片

如何控制背景图片的平铺方式
background-repeat属性
取值：repeat平铺（默认）/repeat-x水平方向平铺/repeat-y垂直方向平铺/norepeat不平铺
应用场景：可以通过背景图片的平铺来降低图片的大小，提升网页的访问速度
注意点：同一个标签可以设置背景颜色和背景图片，如果颜色和图片同时存在，那么图片会覆盖颜色

如何控制背景图片的位置？
在css中有一个叫做background-position：属性，就是专门用于控制背景图片的位置
格式：background-position：水平方向 垂直方向
取值：
1.具体的方位名称
水平方向：left  center right
垂直方向：top  center bottom
2.具体的像素
如：100px 100px
一定要写单位，可以接收负值
网页的大幅图片一般都设置居中显示，中间的是比较重要的内容

背景属性缩写的格式
background：背景颜色 背景图片 平铺方式 关联方式 定位方式
注意点：background中任何一个属性都可以省略
背景关联方式
默认情况下背景图片会随着滚动条的滚动而滚动，如果不想让背景图片随着滚动条的滚动而滚动，那么我们就可以设置修改背景图片和滚动条的关联方式
在css中有一个叫做background-attachment的属性，这个属性就是专门用于修改关联方式的
格式：
background-attachment：scroll
取值：scroll 默认值，会随着滚动条的滚动而滚动
          fixed  不会随着滚动条的滚动而滚动

背景图片和插入图片的区别？
1、背景图片只是一个装饰不会占位置，而插入图片会占位置
2、背景图片有定位属性，所以可以很方便的控制图片的位置，而插入图片没有定位属性，所以控制图片的位置不太方便
*插入图片的语义比背景图片的语义要强，所以在企业开发中如果你的图片想被搜索引擎收录，那么拓建使用插入图片

css精灵图是一种图像合成技术
作用：可以减少请求的次数，以及可以降低服务器的处理压力
css的精灵图需要配合背景图片和背景定位来使用

边框属性
边框属性就是环绕在标签宽度和高度周围的线条
边框属性的格式
1、连写（同时设置四条边的边框）
border：边框的宽度 边框的样式 边框的颜色
注意点：连写格式中颜色属性可以省略，省略之后显示默认颜色黑色
             连写格式中样式不能省略，省略之后就没有了
             连写格式中宽度可以省略，省略之后还是可以看到边框
2、连写（分别设置四条边的边框）
border-top：边框的宽度 边框的样式 边框的颜色
border-right：边框的宽度 边框的样式 边框的颜色
border-bottom：边框的宽度 边框的样式 边框的颜色
border-left：边框的宽度 边框的样式 边框的颜色
可以给边框设置不一样的颜色，样式，宽度
3、连写（分别设置四条边的边框）
border-width：top right bottom left
border-style：top right bottom left
border-color：top right bottom left
这三个属性的取值省略时的规律
01上 右 下 左>上 右 下>左边的取值和右边一样
01上 右 下 左>上 右 >左边的取值和右边一样，下边的取值和上边的一样
01上 右 下 左>上>右下左边取值和上边一样
4、非连写格式
for  example：
border-top-width：；
border-right-style：；
border-bottom-color：；

内边距就是内容与边框的距离
格式：
非连写：
padding-top:;
padding-right:;
padding-bottom:;
padding-left:;

连写
padding：上  右  下  左

外边距就是标签与标签的距离
格式：
非连写
margin-top:;
margin-right:;
margin-bottom:;
margin-left:;

连写
margin：上 右 下 左
 注意点：外边距的那部分没有背景颜色

外边距合并现象
在默认布局的垂直方向上，默认情况下外边距会出现合并现象，谁的外边距大就听谁的。


盒子模型
盒子宽高：
内容宽高：只需要看width和height就可以了
元素宽高：需要看左边框+左内边距+内容+右内边距+右边框
元素空间宽高：需要看左外边距+左边框+左内边距+内容+右内边距+右边框+右外边距

CSS3中新增了1个box-sizing属性，这个属性可以保证我们给盒子新增padding和border之后，盒子的元素的宽度和高度不变。
2.box-sizing属性是如何保证增加padding和border之后要想保证盒子元素的宽高不变，那么就必须减去一部分内容的宽度和高度。
3.box-sizing取值：
（1）contenet-box； 
默认，此时 元素的宽高= 边框+内边距+内容宽高
（2）border-box;
元素的宽高 = width属性/height属性

如果两个盒子是嵌套关系，那么设置了里面一个盒子的顶部
的外边距看，外面的一个盒子也会被顶下来。
2.如果外面的盒子的盒子不想被一起定下来，那么可以给
外面的盒子添加边框属性。
3.在企业开发中，一般情况下如果需要控制嵌套关系盒子之间的距离，
应该首先考虑padding，其次在考虑margin，
margin本质上是用于控制兄弟关系之间的间隙的

在嵌套关系的盒子中，我们可以利用margin：0 auto；的方式来让里面的盒子在外面的盒子水平居中
2.margin：0 auto；只对水平方向有效，对垂直方向无效。

1.text-align:center;和margin:0 auto;区别、
text-alian只是设置文字和图片水平居中。
margin:0 auto;让盒子自己居中。

为什么要清空默认边距（外边距和内边距）
在企业开发中为了更好的控制盒子的宽度和计算盒子的宽高等等。
格式：
第一种方法
*{
margin:0;
padding0;
}
注意点
通配符选择器会找到当前界面中所有的标签，所以性能不好
在企业开发中用这个开头清空
body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,textarea,p,blockquote,th,td{margin:0;padding:0

行高和盒子高度不同！
--line-height:行高；height：盒子高；
行高：line-height：
默认情况下，文字在行高中默认垂直居中，
行高会撑高盒子，
在企业开发中，经常将 只要行高和盒子高一样，文字就会垂直居中。
--盒子中有多行文字，不能使用设置行高等于盒子高度，让文字垂直居中，只能通过padding来设置。
--前端经验：盒子中存储的文字，一般已盒子左边内边距为基准，不会已右边距为基准，右边距有误差，文字左边距是准确的，右边距一般不准。因为右边如果放不下一个文字，文字就会换行显示，所以文字和内边距间距离就会有误差。


在css中所有的行都有自己的行高
行高和字号
1、文字在行高中默认是垂直的
2、在企业开发中我们经常将盒子的高度和行高设置为一样，那么就可以保证一行文字在盒子的高度中是垂直居中的简而言之就是：要想一行文字在盒子中垂直居中，那么只需要设置这行文字的行高等于盒子的高即可
3、在企业开发中如果一个盒子有多行文字，那么我们就不能使用设置行高等于盒子的高来实现让文字垂直居中，只能通过设置padding来让文字居中

在企业开发中如果一个盒子中存储的是文字，那么一般情况下我们会以盒子左边的内边距为基准，不会以右边的内边距为基准，因为这个右边的内边距有误差
右边的内边距误差从何而来？因为右边如果放不下一个文字，那么文字就会换行显示，所以文字和内边距之间的距离就有了误差
由于每行文字都有行高，所以顶部内边距就是顶部的边框到行高的顶部的距离

编写网页的顺序是由外到内，自上到下



网页的布局方式就是指浏览器是如何对网页中的元素进行排版的。
①标准流（文档流/普通流）排版方式（浏览器默认）②浮动流排版方式③定位流排版方式
在CSS中将元素分为三类，分别是块级元素、行内元素、行内块级元素（区别是是否独占一行，是否能设置宽高）
块级元素就会垂直排版，行内元素和行内块级元素会水平排版

浮动流排版方式：块级元素改为行内块级元素display：inline-block;float:right;
浮动流是一种“半脱离标准流”的排版方式
浮动流只有一种排版方式，即水平排版，它只能设置某个元素左对齐或者右对齐
浮动流中没有居中对齐，也就是没有center取值
在浮动流中不可以使用margin:0 auto;该值无效
特点：
1、浮动流不区分块级元素、行内、行内块级元素的，无论是块级元素、行内、行内块级元素都可以水平排版的
2、在浮动流中无论是块级元素、行内元素还是行内块级元素都可以设置宽高
3、综上，浮动流中的元素和标准流中的行内块级元素很像

浮动元素的脱标：脱离标准流
当某一个元素浮动之后，这个元素看上去就像被从标准流中删除了一样，这个就是浮动元素的脱标
浮动元素脱标之后的影响：
如果前面一个元素浮动了，而后面一个元素没有浮动，那么这个时候前面的一个元素就会盖住后面一个元素

浮动元素的排序规则
1、相同方向上的浮动，先浮动的元素会显示在前面，后浮动的元素会显示在后面
2、不同方向上的浮动元素，左浮动会找左浮动，右浮动会找右浮动
3、浮动元素浮动之后的位置，由浮动元素之前在标准流中的位置来确定

贴靠现象：
              当父元素不足以容纳所有的浮动元素时，最后一个浮动元素就会贴在前一个浮动元素所依附的元素，以此类推，直到找到父元素，此时就会依附在父元素，此时不管父元素能否容纳

在标准流中内容的高度可以撑起父元素的高度
在浮动流中浮动元素是不可以撑起父元素的高度的

给前面一个父元素设置高度
注意点：
在企业开发中，我们能不写高度就不写高度

清除浮动：
一、
1给父元素写高度。
2.给后面盒子添加属性clear：left ，right ，both ，none。
-none：默认取值，按照左浮动找左浮动，右浮动找右浮动；
-both：企业开发中一般写both，不要找前面的左浮动，和右浮动。
注意：
- clear：both这个属性的margin属性失效。
二、
2..外墙法
2.1在两个盒子中间添加一个块级元素
2.2给这个额外的块级元素设置clear：both；属性。
注意点：
外墙外它可以让第二个盒子使用margin-top属性。
外墙外不可以让第一个盒子使用margin-bottom属性。
直接给添加的块级元素设置高度。

内墙法
.1在第一个盒子中的所有子元素最后添加一个额外的块级元素
.2给这个额外的块级元素设置clear：both；属性。
注意点
内墙外它可以让第二个盒子使用margin-top属性。
内墙外也可以让第一个盒子使用margin-bottom属性。

外墙法和内墙法的区别
外墙法不能撑起第一个盒子的高度，而内墙法可以撑起盒子的高度。
在 企业开发中不常用隔墙法来清除浮动。


伪元素选择器
伪元素选择器的作用就是给指定标签的内容前面添加一个子元素或者给指定标签的内容后面添加一个子元素
格式：
标签名称：：before{属性名称：值；}给指定标签前面添加一个子元素
标签名称：：after{属性名称：值；}给指定标签后面添加一个子元素

隔墙法增加了无用的标签，前端开发中讲究语义和样式分开，所以推荐使用伪元素选择器来清除浮动
例如：
.box::after{
          content:"";
          display:block;
          height:0;
          visibility:hidden;
          clear:both;}
注意：此方法在ie6中不兼容，需要加上下列语句解决：
.box{
        *zoom:1;}

默认标签的内容可以超出标签的范围，overflow：hidden；
清除浮动：box1添加
overflow：hidden；
注意点：ie6无效；
加*zoom：1；ok了
overflow：hidden：作用：
1 裁剪超出标签范围的内容；
2.清除浮动；
3给外面盒子设置overflow，让里面的盒子设置margin-top之后，外面的盒子不设置border也 不被顶下来。

在企业开发中，想让两个盒子顶端对其，把两个盒子都进行浮动就可以了

网易注册界面实战注意点：
1、在企业开发编写程序时要适当的添加注释，方便自己与同事查找标签提高效率。比如：
<!---头部开始--->
<!---头部结束--->
2、清空样式，除了要清空margin，padding
3、清空默认样式
4、利用body设置整个界面的文字信息
  文字大小  文字字体  文字颜色


定位流
1、相对定位
2、绝对定位
3、固定定位
4、静态定位

1.1 什么是相对定位？
相对定位就是相对于自己以前在标准流中的位置来移动
格式
格式：选择器{
           position:relative;
           (方向属性例如：top/right/left/bottom):20px;
}
1.2相对定位注意点
01.相对定位是不脱离标准流的，会继续在标准流中占用一份空间
02.在相对定位中同一个方向上的属性只能使用一个
03.由于相对定位是不脱离标准流的，所以在相对定位中是区分块级元素/行内元素/行内块级原素
04.由于相对定位是不脱离标准流的，并且相对定位的元素会占用标准流中的位置，所以当给相对定位的元素设置margin/padding等属性的时候会影响到标准流的布局
1.3、相对定位的应用场景
用于对元素进行微调
配合绝对定位使用

2.1什么是绝对定位？
就是相对于body的定位
格式：
position：absolute;

2.2绝对定位注意点
01.绝对定位的元素是脱离标准流的
02.绝对定位是不区分块级元素/行内元素/行内块级元素的
规律：
1、默认情况下所有的绝对定位的元素，无论有没有祖先元素，都会以body作为参考点
2、如果一个绝对定位的元素有祖先元素，并且祖先元素也是定位流，那么这个绝对定位的元素就会以定位流的那个祖先元素作为参考点。只要是祖先都可以
3、指的定位流是相对定位/绝对定位/固定定位
4、定位流中只有静态定位不行
5、如果一个绝对定位的元素有祖先元素，并且祖先元素也是定位流，而且祖先元素中有多个元素都是定位流，那么这个绝对定位元素就会以离他最近的那个定位流的祖先元素为参考点

绝对定位注意点：
1、如果一个绝对定位的元素是以body作为参考点，那么其实是以网页的首屏的宽度作为参考点，而不是以整个网页的宽度和高度作为参考点
2、一个绝对定位的元素会忽略祖先元素的padding

子绝父相
相对定位弊端：相对定位不会脱离标准流，会继续在标准流中占用一份空间，所以不利于布局界面
绝对定位弊端：默认情况下绝对定位的元素会以body作为参考点，所以会随着浏览器的高度宽度的变化而变化
如何让绝对定位的元素水平居中
只需要设置绝对定位元素的left：50%；
然后再设置绝对定位的的margin-left：元素-的宽度的一半  如：-150px；

固定定位
1.固定定位的元素是脱离标准流的，不会占用标准流中的空间
2.固定定位和决定定位一样，不会区分行内、块级，行内块级，可以直接设置宽高
3.固定定位不会随着浏览器的下拉而改变位置


z-index
默认情况下所有元素都有一个z-index属性, 取值是1, z-index属性作用是专门控制元素的覆盖关系的

1.默认情况下定位流的元素会盖住标准流的元素
2.默认情况下定位流的元素后面编写的会覆盖前面编写的
3.如果定位流的元素设置了z-index属性, 那么谁的z-index属性大, 谁就显示在上面

注意点:
2.服从现象
1.1如果两个元素的父元素都没有设置z-index 属性, 那么谁的z-index属性比较大, 谁就显示在上面
1.2如果两个的父元素设置了z-index属性, 那么子元素的z-index属性就会失效, 也就是说谁的父元素的z-index属性比较大谁就会显示在上面



a标签伪类选择器
a标签存在一定的状态：
1.默认状态，从未被访问过
2.被访问过的状态
3.鼠标长按状态
4.鼠标悬停装态
什么是a标签的伪类选择器？
a标签的伪类选择器就是专门用来修改a标签不同状态的样式的
格式：
：link 修改从未被访问过状态下的样式
：visited 修改被访问过状态下的样式
：active 修改鼠标长按状态下的样式
：hover 修改鼠标悬停在a标签上状态下的样式
注意点：
1、a标签的伪类选择器可以单独出现也可以一起出现
2、a标签的伪类选择器如果要一起出现，那么有严格的顺序要求，编写的顺序必须要遵守爱恨原则【l】o【v】e 【h】【a】te
3、如果默认状态的样式和被访问过状态的样式一样，那么可以缩写就写一个a标签就可以

1在企业开发中编写a标签的伪类选择器最好写在标签选择器的后面
2在企业开发中和a标签盒子相关属性的写在标签选择器中（显示模式/宽高/padding/margin）
3在企业开发中和a标签文字/背景相关的都写在伪类选择器中


过渡模块
1:hover这个伪类选择器除了可以用在a标签上,还可以用在其他任何标签上
告诉系统哪个属性需要执行的过渡效果：transition-property：（属性名称）；
告诉系统过渡效果持续的时长：transition-duration：(时间 s)
告诉系统延时多少秒才开始过渡动画：transition-delay：（时间 s）
告诉系统过渡动画的运动速度：transition-timing-function
linear匀速
ease逐渐慢下来
ease-in加速
ease-out减速
ease-in-out先加速后减速
过渡三要素
1.1必须要有属性发生变化
1.2必须告诉系统哪个属性需要执行过渡效果
1.3必须告诉系统过渡效果持续时长。
注意点
当多个属性需要同时执行过渡效果时，用逗号隔开即可。
过渡模块连写：
1.过渡连写格式
transition：过渡属性 过渡时长 运动速度 延迟时间；
2.过渡连写注意点
2.1和分开写一样，如果想给多个属性添加过渡效果也是用逗号隔开即可
2.2连写的时候可以省略后面的两个参数，因为只要编写了前面的两个参数就已经满足了过渡的三要素
2.3如果多个属性运动的速度/延时时间/持续时间都一样，那么可以简写为;transition:all 5s;

编写过渡套路
1.不要管过渡，先编写基本界面
2.修改我们认为需要修改的属性
3.再回过头去给被修改属性的那个元素添加过渡即可 

2D转换模块
transform:rotate(45deg);
/旋转，其中deg是单位，代表多少度/
transform:translate(x,y);
/平移，第一个参数是水平方向，第二个参数是垂直方向(100px,0px)/
transform:scale(x,y);
/缩放，第一个参数是水平方向，第二个参数是垂直方向。取值没单位。如果取值在水平和垂直缩放都一样，那么可以简写为一个参数。/
注意点：
1.如果需要进行多个转换，那么用空格隔开
2.2D的转换模块会修改元素的坐标系，所以旋转之后再平移就不是平移了


2D转换模块-形变中心点
1、默认情况下所有的元素都是以自己的中心点作为参考来旋转的，我们可以通过形变中心点属性来修改他的参考点。
2、transform-origin:0px,0px(第一个参数：水平方向，第二个参数：垂直方向)
3、取值有三种形式：1、具体像素
                                   2、百分比
                                   3、特殊关键字（例如：center、left、top等等）

2D转换模块-旋转轴：想围绕哪个轴旋转，那么只需要在rotate后面加上哪个轴即可（例如：围绕X轴转：rotateX(45deg)）默认情况下都是围绕Z轴旋转


阴影
一.盒子阴影
1.box-shadow：水平偏移 垂直偏移 模糊度 阴影扩展 阴影颜色 内外阴影；
2.盒子的阴影分为内阴影和外阴影，默认为外阴影；
3.快速添加阴影只需写三个参数即可：
box-shadow：水平偏移 垂直偏移 模糊度
默认情况下阴影的颜色和盒子内容颜色一致

二.文字阴影
text-shadow：水平偏移 垂直偏移 模糊度  阴影颜色 

动画模块
过度和动画之间的异同
1、不同点
过渡必须人为的触发才会执行动画
动画不需要人为的触发就能执行动画
2、相同点
过渡和动画都是为了给元素添加动画的
过渡和动画都是系统新增的属性
过渡和动画都必须满足三要素才会有动画效果

动画三要素：
1、执行什么动画，什么动画，持续时长
animation-name：abcd；
animation-duration：3s；
2、告诉系统我们需要自己创建一个名字叫abcd的动画。
@keyframesabcd｛
from｛margin-left：0｝
to｛margin-left：50px；｝
｝
 其他属性：
告诉动画持续的时长
animation-duration
告诉系统多少秒之后开始执行动画
animation-delay
告诉系统动画执行的速度
animation-timing-function
告诉系统需要执行几次
animation-iteration-count
告诉系统是否需要执行往返动画（取值：normal 执行完一次之后回到起点执行下一次，aleternate执行完一次之后往回执行下一次）
animation-play-state：（取值running执行，paused暂停）
告诉系统是否需要执行动画

创建动画的第二中形式
百分比的形式：需要设定元素为绝对定位，然后通过定位实现动画

动画有一定的状态的
1.等待状态
2.执行状态
3.结束状态
animation-fill-mode:
指定动画等待状态和结束状态的样式
取值：
none：不做 任何改变
forwards:让元素结束状态保持动画最后一帧的样式
backwards：让元素等待状态的时候显示动员第一帧的样式
both：让元素等待状态显示动画第一帧的样式，让元素结束状态
保持动画最后一帧的样式

animation :动画名称 动画时长 动画运动速度 延迟时间 执行次数 往返动画
动画模块简写： 
animation :动画名称 动画时长

无限滚动
在最后的图片后面再接接上起使的图片，这样跳转就看不出来了


3D模块
1.什么是2d和什么是3d
2d就是一个平面，只有高度和宽度，没有厚度
3d就是一个立体，有高度和宽度，还有厚度
默认情况下所有的元素都是呈2d展示的
2.如何让某个元素呈3d展现
和透视一样，想看到某个元素的3d属性效果：只要给他的父元素添加一个transform-style属性
然后设置prescrve-3d即可


3D正方体盒子，每一面都是正面的代码
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>CSS-3D转化模块-正方体终极</title>
    <style>
        *{
            margin: 0;
            padding: 0;
        }
        ul {
            width: 200px;
            height: 200px;
            box-sizing: border-box;
            /*border: 1px solid #000;*/
            margin: 200px auto;
            position: relative;
            transform-style: preserve-3d;
            animation: xz 10s linear 0s infinite normal;
        }
        @keyframes xz {
            0%{
                transform: rotateX(0deg);
            }
            25%{
                transform: rotateX(90deg);
            }
            50%{
                transform: rotateX(180deg);
            }
            75%{
                transform: rotateX(270deg);
            }
            100%{
                transform: rotateX(360deg);
            }
        }
        ul:hover{
            animation: xz2 10s linear 0s infinite normal;
        }
        @keyframes xz2 {
            0%{
                transform: rotateY(0deg);
            }
            25%{
                transform: rotateY(90deg);
            }
            50%{
                transform: rotateY(180deg);
            }
            75%{
                transform: rotateY(270deg);
            }
            100%{
                transform: rotateY(360deg);
            }
        }
        ul li{
            list-style: none;
            width: 200px;
            height: 200px;
            font-size: 80px;
            line-height: 200px;
            text-align: center;
            position: absolute;
            left: 0;
            top: 0;
        }
        ul li:nth-child(1){
            background-color: red;
            transform: rotateX(90deg) translateZ(100px);
        }

        ul li:nth-child(2){
            background-color: blue;
            transform: rotateX(180deg) translateZ(100px);
        }
        ul li:nth-child(3){
            background-color: green;
            transform: rotateX(270deg) translateZ(100px);
        }
        ul li:nth-child(4){
            background-color: yellow;
            transform: rotateX(360deg) translateZ(100px);
        }
        ul li:nth-child(5){
            background-color: purple;
            transform: translateX(-100px) rotateY(90deg);
        }
        ul li:nth-child(6){
            background-color: pink;
            transform: translateX(100px) rotateY(90deg);
        }

    </style>
</head>
<body>
<ul>
    <li>1</li>
    <li>2</li>
    <li>3</li>
    <li>4</li>
    <li>5</li>
    <li>6</li>
</ul>
</body>
</html>

长方体
只要给每一面设置scale属性就可以了
注意点：只要父元素被拉伸了，子原素也会被拉伸

填满整个网页
background-size:cover;

注意点：动画中如果有和默认样式同名的属性，会覆盖
默认样式中同名的属性
2.在编写动画的时候，固定不变的值写在前面，需要变化的值写在后面


1.什么是背景尺寸属性
背景尺寸属性是CSS3中新增的一个属性，专门用于设置背景图片的大小。
具体像素 background-size:100px200px;(变形)
百分比background-size:50% 80%（变形）
等比拉伸background-size:auto  100px;（不变形）
background-size:cover;
cover的含义
1、告诉系统图片需要等比拉伸
2、图片需要拉伸到宽度和高度都要填满元素
Background-size:contain;
contain的含义
1、告诉系统图片需要等比拉伸
2、告诉系统宽度或者高度都填满元素

背景图片定位区域：
告诉图片从什么区域开始显示
background-origin：padding-box    默认就是从padding开始显示
background-origin：border-box     设置图片从边框开始显示
background-origin：content-box    设置图片从内容区域开始显示

背景绘制区域：
专门用于指定从哪个区域开始绘制背景的，默认会从border区域开始绘制背景
background-origin：padding-box      设置从padding区域开始绘制背景
background-origin：border-box     默认
background-origin：content-box    设置从内容区域开始绘制背景

多张背景图片用逗号隔开，先写的背景会盖住后写的背景

多张背景推荐拆开编写：
background-image:url(“”),url();
background-repeat:no-repeat,no-repeat;
background-position:left top,right  top;


css书写格式：
1.行内样式
第一个位置，可以直接将css代码写在开始标签中
2.内嵌样式
可以在一对head标签当中写上一对style标签，然后再style标签总编写css代码
3.外链样式--企业开发中一般都用外链样式
可以单独新建一个.css的文件，把CSS代码写到这个文件中，然后通过link标签把
.html文件关联起来
4.导入样式
可以单独新建一个.css的文件，把CSS代码写到这个文件中，然后通过
@import把.html文件关联起来
外链样式和导入样式区别：
外链样式是通过link标签关联而导入样式是通过@import关联
而@import是css2.1推出的，所以有兼容问题
2.外链样式在显示界面的时候，会先加载css样式，再加载结构，所以用户看到界面时
一定已经设置了样式
导入样式在显示界面的时候，会先加载结构，再加载样式，所以用户看到界面的时不一定
已经设置了样式。

1.编写网站要做的第一件事情
创建站点文件夹，并且创建一些子文件夹和子文件
注意点：
创建站点文件夹可以是中文
但是站点文件夹下面的子文件夹和子文件不能出现中文

2.重置所有默认的样式和设置一些全局样式，并且将伸直样式的css文件
和对应的界面关联起来。